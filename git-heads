#!/bin/sh
##
## git-heads -- show unmerged branches with git-log(1)
##
## Usage: git-heads [--all | --local | --remote] [--branches] [(--contains | --merged | --no-merged) [<commit>]] [git-log-OPTION]...
## Usage: git-heads [--all | --local | --remote] [--heads] [git-log-OPTION]...
## Options:
##     -a, --all                 list all branches
##     -l, --local               only local branches
##     -r, --remote              only remote branches
##     -b, --branch, --branches  list branches
##     -h, --head, --heads       only branches without children

git_exec_path="$(git --exec-path)"

ifs="$IFS"
IFS=":"
for dir in $git_exec_path; do
    [ -f "$dir/git-sh-setup" -a -r "$dir/git-sh-setup" ] \
            && . "$dir/git-sh-setup" && break
done || {
    echo "fatal: unable to find and source git-sh-setup in" \
         "GIT_EXEC_PATH=$git_exec_path" >&2
    exit 1
}
IFS="$ifs"

require_work_tree

if git config --get-colorbool color.log; then
    color_auto="always"
else
    color_auto="never"
fi
git_branch_args="--color=never"
git_branch_scope=""
git_log_args="--color=$color_auto -n 1"
heads="true"

while [ "$#" -gt 0 ]; do
    case "$1" in
        (-a|--all)
            git_branch_scope="-a"
            shift
            ;;
        (-l|--local)
            git_branch_scope=""
            shift
            ;;
        (-r|--remote)
            git_branch_scope="-r"
            shift
            ;;
        (-b|--branch|--branches)
            heads="false"
            shift
            ;;
        (-h|--head|--heads)
            heads="true"
            shift
            ;;
        (--contains|--merged|--no-merged)
            if [ -n "$2" -a "$2" = "${2#-}" ]; then         ## If it begins with
                git_branch_args="$git_branch_args '$1=$2'"  ## a "-" it is just
                shift 2                                     ## another option.
            else
                git_branch_args="$git_branch_args '$1=HEAD'"
                shift
            fi
            heads="false"
            ;;
        (--contains=*|--merged=*|--no-merged=*)
            git_branch_args="$git_branch_args '$1'"
            heads="false"
            shift
            ;;
        (--color)         ## Handle git-log's color option explicitly because
            case "$2" in  ## it gets confused by piping to git_pager.
                (auto)
                    git_log_args="$git_log_args --color=$color_auto"
                    shift 2
                    ;;
                (always|never)
                    git_log_args="$git_log_args --color=$2"
                    shift 2
                    ;;
                (*)
                    git_log_args="$git_log_args --color=always"
                    shift
                    ;;
            esac
            ;;
        (--color=auto)
            git_log_args="$git_log_args --color=$color_auto"
            shift
            ;;
        (--color=*)
            git_log_args="$git_log_args '$1'"
            shift
            ;;
        (--no-color)
            git_log_args="$git_log_args --color=never"
            shift
            ;;
        (*)
            git_log_args="$git_log_args '$1'"
            shift
            ;;
    esac
done

branches() {
    git branch --color=never $git_branch_scope "$@" \
            | sed '/^\* (no branch)$\| -> /d;s/^..//' \
            | xargs git rev-parse --revs-only
}

## git-rev-list topologically sort the revs and annotates the with their
## children.  Commits without children are heads.
no_children() {
    branches | git rev-list --children --stdin --topo-order | grep -v ' '
}

## A branch is a head which wasn't merged in any other branch.
pairwise_unmerged() {
    local LANG=C                      ## speed up sort and uniq a bit
    local refs="$(branches | wc -l)"

    branches | sort -u | while read -r ref; do
        branches --no-merged="$ref" | { echo "$ref"; cat; } | sort -u
    done | sort | uniq -c | sed -n "s/^[[:space:]]*$refs[[:space:]]*//p"
}

if "$heads"; then
    no_children
    #pairwise_unmerged
else
    eval branches $git_branch_args  ## let git-rev-list do the sorting
fi | git rev-list --date-order --stdin --no-walk | while read -r ref; do
    echo
    eval git log $git_log_args "'$ref'" || exit 1
done | tail -n +2 | git_pager

