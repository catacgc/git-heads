#!/bin/sh
##
## Copyright (c) 2010, Sebastian Schwarz <seschwar@googlemail.com>
##
## Licensed under the MIT License; see accompanying `LICENSE` file.
##

## A newline character.
N="
"
USAGE="[--all | --local | --remote] [--branches] [(--contains | --merged | --no-merged) [COMMIT]] [git-log-OPTION]...
       git-heads [--all | --local | --remote] [--heads] [git-log-OPTION]..."

git_exec_path="`git --exec-path`"

ifs="$IFS"
IFS=":"
for dir in $git_exec_path; do
    test -f "$dir/git-sh-setup" -a -r "$dir/git-sh-setup" \
            && . "$dir/git-sh-setup" && break
done || {
    echo "fatal: unable to find and source git-sh-setup in" \
         "GIT_EXEC_PATH=$git_exec_path" >&2
    exit 1
}
IFS="$ifs"

require_work_tree


branches() {
    ifs="$IFS"
    IFS="$N"
    git rev-parse --revs-only `git branch "$@" --color=never | sed \
            -e 's/^[ *] //' -e 's/^(no branch)$/HEAD/' -e 's/ -> .*$//'`
    IFS="$ifs"
}


## git-rev-list topologically sort the revs and annotates the with their
## children.  Commits without children are heads.
no_children() {
    branches "$@" | git rev-list --children --stdin --topo-order | grep -v ' '
}


## A branch is a head which wasn't merged in any other branch.
pairwise_unmerged() {
    local LANG=C                      ## speed up sort and uniq a bit
    local refs="`branches | wc -l`"

    branches | sort -u | while IFS= read -r ref; do
        branches --no-merged="$ref" | { echo "$ref"; cat; } | sort -u
    done | sort | uniq -c | sed -n "s/^[[:space:]]*$refs[[:space:]]*//p"
}


## prefix PREFIX STRING
prefix() {
    test "${2#$1}" != "$2"
}


main() {
    if git config --get-colorbool color.log; then
        color_auto="always"
    else
        color_auto="never"
    fi
    git_branch_args="--color=never"
    git_branch_scope=""
    git_log_args="--color=$color_auto$N--max-count=1"
    mode="heads"

    while test "$#" -gt 0; do
        case "$1" in
            (-h|--help)  ## Automatically handled by git(1) and git-sh-setup.  Just
                exit 0   ## set $USAGE.
                ;;
            (-a|--all)
                git_branch_scope="-a"
                shift
                ;;
            (-l|--local)
                git_branch_scope=""
                shift
                ;;
            (-r|--remote)
                git_branch_scope="-r"
                shift
                ;;
            (-b|--branch|--branches)
                mode="branches"
                shift
                ;;
            (--head|--heads)
                mode="heads"
                shift
                ;;
            (--contains|--merged|--no-merged)
                if test "$#" -lt 2 || prefix - "$2"; then        ## $2 is
                    git_branch_args="$git_branch_args$N$1=HEAD"  ## another
                    shift                                        ## argument
                else
                    git_branch_args="$git_branch_args$N$1=$2"
                    shift 2
                fi
                mode="branches"
                ;;
            (--contains=*|--merged=*|--no-merged=*)
                git_branch_args="$git_branch_args$N$1"
                mode="branches"
                shift
                ;;
            (--color)
                case "$2" in
                    (always|never)
                        git_log_args="$git_log_args$N--color=$2"
                        shift 2
                        ;;
                    (auto)
                        git_log_args="$git_log_args$N--color=$color_auto"
                        shift 2
                        ;;
                    (*)
                        git_log_args="$git_log_args$N--color"
                        shift
                        ;;
                esac
                ;;
            (--color=auto)
                git_log_args="$git_log_args$N--color=$color_auto"
                shift
                ;;
            (*)
                git_log_args="$git_log_args$N$1"
                shift
                ;;
        esac
    done

    IFS="$N"
    case "$mode" in
        (branches)
            branches $git_branch_args $git_branch_scope
            ;;
        (heads)
            no_children $git_branch_scope
            ;;
        (*)
            die "unable to list commits for mode $mode"
            ;;
    esac | git rev-list --date-order --stdin --no-walk \
            | while IFS= read -r ref; do
        echo
        git log $git_log_args "$ref" -- || exit "$?"
    done | tail -n +2 | git_pager
}


main "$@"

