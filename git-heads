#!/bin/sh
##
## git-heads -- show unmerged branches with git-log(1)
##
## Usage: git-heads [OPTIONS] [git-log-OPTION...]
##     -a, --all     list all branches
##     -l, --local   only local branches
##     -r, --remote  only remote branches
##     --branches    list branches
##     --heads       only branches without children

git_exec_path="$(git --exec-path)"

ifs="$IFS"
IFS=":"
for dir in $git_exec_path; do
    [ -f "$dir/git-sh-setup" -a -r "$dir/git-sh-setup" ] \
            && . "$dir/git-sh-setup" && break
done || {
    echo "fatal: unable to find and source git-sh-setup in" \
         "GIT_EXEC_PATH=$git_exec_path" >&2
    exit 1
}
IFS="$ifs"

require_work_tree

if git config --get-colorbool color.log; then
    color_auto="always"
else
    color_auto="never"
fi
git_branch_args="--color=never"
git_log_args="--color=$color_auto -n 1"
branches=""
heads="true"

while [ "$#" -gt 0 ]; do
    case "$1" in
        (-a|--all)
            branches="-a"
            shift
            ;;
        (-l|--local)
            branches=""
            shift
            ;;
        (-r|--remote)
            branches="-r"
            shift
            ;;
        (--branches)
            heads="false"
            shift
            ;;
        (--heads)
            heads="true"
            shift
            ;;
        (--contains|--merged|--no-merged)
            if [ -n "$2" -a "$2" = "${2#-}" ]; then
                git_branch_args="$git_branch_args '$1=$2'"
                shift 2
            else
                git_branch_args="$git_branch_args '$1=HEAD'"
                shift
            fi
            heads="false"
            ;;
        (--contains=*|--merged=*|--no-merged=*)
            git_branch_args="$git_branch_args '$1'"
            heads="false"
            shift
            ;;
        (--color)
            case "$2" in
                (always)
                    git_log_args="$git_log_args --color=always"
                    shift 2
                    ;;
                (auto)
                    git_log_args="$git_log_args --color=$color_auto"
                    shift 2
                    ;;
                (never)
                    git_log_args="$git_log_args --color=never"
                    shift 2
                    ;;
                (*)
                    git_log_args="$git_log_args --color=always"
                    shift
                    ;;
            esac
            ;;
        (--color=auto)
            git_log_args="$git_log_args --color=$color_auto"
            shift
            ;;
        (--color=*)
            git_log_args="$git_log_args '$1'"
            shift
            ;;
        (--no-color)
            git_log_args="$git_log_args --color=never"
            shift
            ;;
        (*)
            git_log_args="$git_log_args '$1'"
            shift
            ;;
    esac
done

branches() {
    eval git branch $branches $git_branch_args \
            | grep -v '^\* (no branch)$\| -> ' | sed 's/^..//' \
            | xargs git rev-parse --revs-only | sort -u
}

heads() {
    local LANG=C  ## speed up sort and uniq a bit
    local tmp1="$(mktemp --tmpdir=/dev/shm || mktemp)"
    local tmp2="$(mktemp --tmpdir=/dev/shm || mktemp)"
    local tmp

#   git for-each-ref --format='%(objectname)' --sort=objectname \
#           refs/heads refs/remotes | uniq | while read -r ref; do
    git branch --color=never $branches \
            | grep -v '^\* (no branch)$\| -> ' | sed 's/^..//' \
            | xargs git rev-parse --revs-only | sort -u | while read -r ref; do
        git branch --color=never $branches --no-merged="$ref" \
                | grep -v '^\* (no branch)$\| -> ' | sed 's/^..//' \
                | xargs git rev-parse --revs-only | { echo "$ref"; cat; } \
                | sort - "$tmp1" | if [ -z "$tmp" ]; then cat; else uniq -d; fi > "$tmp2"
        tmp="$tmp1"
        tmp1="$tmp2"
        tmp2="$tmp"
    done

    cat "$tmp1"
    rm --force -- "$tmp1" "$tmp2"
}

if "$heads"; then
    heads
else
    branches
fi | while read -r ref; do
    echo
    eval git log $git_log_args "'$ref'" || exit 1
done | tail -n +2 | git_pager

